# 窗口坐标系统问题分析与解决方案

## 问题现象

在窗口模式下，AI 返回的坐标位置比实际点击位置**偏低约 35 像素**（与标题栏高度接近）。

## 数据流分析

### 完整流程

```
1. 窗口截图
   └─ node-screenshots: window.captureImage()
      └─ 输出：Base64 图片（实际分辨率）
      └─ window.x, y, width, height（坐标系统？）

2. AI 分析
   └─ Insight 分析截图
      └─ 返回坐标：(x, y) ← 基于截图实际分辨率

3. 坐标转换（windowsDevice.transformCoordinates）
   └─ 输入：(x, y) - AI 返回的物理坐标
   └─ 输出：屏幕绝对坐标

4. 鼠标操作（windowsNative.mouseClickAsync）
   └─ convertToLogicalCoordinates（再次转换？）
   └─ nut-js mouse.move（逻辑坐标）
```

## 可能的问题点

### 问题 1：截图是否包含标题栏？

**假设 A：截图包含标题栏（从标题栏顶部开始）**

```
截图坐标系（AI 看到的）：
(0, 0) ──────────── X
│ [标题栏 35px]
│ [客户区内容]
Y
```

**可能的影响**：

- 如果 `window.y` = 客户区位置（不是标题栏顶部）
- AI 返回客户区按钮坐标 = (100, 35) ← 相对于标题栏顶部
- 转换：screenY = window.y + 35
- **结果**：位置偏高 35 像素 ✗

**假设 B：截图不包含标题栏（只截客户区）**

```
截图坐标系（AI 看到的）：
(0, 0) ──────────── X
│ [客户区内容]
Y
```

**可能的影响**：

- 如果 `window.y` = 窗口完整位置（包含标题栏）
- AI 返回坐标：正确
- 转换：screenY = window.y + aiY
- **结果**：如果 window.y 是标题栏顶部，应该正确 ✓

### 问题 2：window.x, y 的坐标系统是什么？

**可能性 A：窗口完整位置（包含标题栏的左上角）**

```
window.x, y = 窗口完整位置
window.width, height = 窗口完整尺寸（含标题栏）
```

**可能性 B：客户区位置（不含标题栏）**

```
window.x, y = 客户区位置
window.width, height = 客户区尺寸
```

**如何验证**：

- 使用 Windows API `GetWindowRect()` vs `GetClientRect()`
- 对比 node-screenshots 返回的值

### 问题 3：DPR 坐标系统不匹配

**问题描述**：

- 窗口截图实际分辨率 vs 窗口逻辑尺寸
- AI 返回的坐标基于截图实际分辨率（物理像素）
- `window.x, y` 可能是逻辑坐标
- 如果 DPR ≠ 1，需要转换

**当前实现**：

```typescript
// windowsDevice.ts
const windowDpr = cachedSize?.dpr || 1;  // 已计算
logicalX = x / windowDpr;  // 物理 → 逻辑
screenX = logicalX + window.x;  // 窗口相对 → 屏幕绝对

// windowsNativeImpl.ts
const logical = convertToLogicalCoordinates(screenX, screenY);  // ❌ 再次转换？
// 使用的是全屏 DPR，不是窗口 DPR！
```

**问题**：双重 DPR 转换？

### 问题 4：全屏 DPR vs 窗口 DPR

**场景**：

- 全屏 DPR = 1.5（150% 缩放）
- 窗口可能也有自己的 DPR
- `windowsNative.convertToLogicalCoordinates` 使用全屏 DPR

**影响**：

- 如果窗口 DPR ≠ 全屏 DPR，转换会出错
- 或者双重转换导致坐标错误

## 解决方案

### 方案 1：验证并修正标题栏偏移（如果问题存在）

**步骤**：

1. 实际测试：截图是否包含标题栏
2. 验证 `window.y` 是客户区位置还是窗口完整位置
3. 如果窗口截图包含标题栏，且 `window.y` 是客户区位置：
   - 需要从 AI 的 Y 坐标中减去标题栏高度
   - `clientAreaY = aiY - TITLE_BAR_HEIGHT`
   - `screenY = window.y + clientAreaY`

**实现**：

```typescript
// 如果确认需要标题栏偏移
const TITLE_BAR_HEIGHT = 35;  // 或动态获取
if (截图包含标题栏 && window.y是客户区位置) {
  y = y - TITLE_BAR_HEIGHT;
}
```

### 方案 2：统一 DPR 处理（避免双重转换）

**问题**：`transformCoordinates` 已经除以窗口 DPR，但 `mouseClickAsync` 又除以全屏 DPR

**解决方案 A：transformCoordinates 不转换 DPR，让 mouseClickAsync 统一处理**

```typescript
// transformCoordinates 输出屏幕物理坐标
const screenX = (x / windowDpr) + (window.x * windowDpr);  // 需要乘以 DPR？
const screenY = (y / windowDpr) + (window.y * windowDpr);
return { x: screenX, y: screenY };  // 屏幕物理坐标
// mouseClickAsync 再除以全屏 DPR
```

**问题**：需要确认 `window.x, y` 是逻辑坐标还是物理坐标

**解决方案 B：transformCoordinates 转换为屏幕逻辑坐标，mouseClickAsync 不再转换**

```typescript
// transformCoordinates
const logicalX = x / windowDpr;
const logicalY = y / windowDpr;
const screenX = logicalX + window.x;  // 假设 window.x 是逻辑坐标
const screenY = logicalY + window.y;
return { x: screenX, y: screenY };  // 屏幕逻辑坐标

// mouseClickAsync - 需要修改为不转换，或检查是否已转换
async mouseClickAsync(x: number, y: number, isLogical = false) {
  const logical = isLogical ? { x, y } : this.convertToLogicalCoordinates(x, y);
  await mouse.move([new Point(logical.x, logical.y)]);
}
```

### 方案 3：动态检测标题栏高度（如果截图包含标题栏）

**思路**：

1. 检测截图是否包含标题栏
2. 如果包含，计算标题栏高度
3. 在坐标转换时减去标题栏高度

**实现思路**：

```typescript
// 通过截图特征检测标题栏（颜色、高度等）
// 或通过 Windows API 获取窗口信息对比
```

### 方案 4：使用 Windows API 获取精确坐标

**思路**：

1. 使用 `GetWindowRect()` 获取窗口完整位置
2. 使用 `GetClientRect()` + `ClientToScreen()` 获取客户区位置
3. 根据截图范围选择正确的坐标系统

**优点**：准确、可靠
**缺点**：需要 native 模块或 FFI

## 推荐验证步骤

### 步骤 1：验证截图内容

```
1. 保存窗口截图到文件
2. 手动查看是否包含标题栏
3. 测量标题栏高度
```

### 步骤 2：验证 window.x, y 的含义

```
1. 使用 Spy++ 或类似工具查看窗口
2. 对比 node-screenshots 返回的 window.x, y
3. 判断是窗口完整位置还是客户区位置
```

### 步骤 3：验证 DPR

```
1. 打印窗口逻辑尺寸 vs 截图实际尺寸
2. 计算窗口 DPR = 截图宽度 / 窗口逻辑宽度
3. 打印全屏 DPR
4. 对比两者是否一致
```

### 步骤 4：测试坐标转换

```
1. 在窗口内选择一个明显的位置（比如左上角按钮）
2. AI 返回坐标 (aiX, aiY)
3. 打印转换过程：
   - AI 坐标：(aiX, aiY)
   - 窗口逻辑坐标：(aiX/windowDpr, aiY/windowDpr)
   - 屏幕绝对坐标：(logicalX + window.x, logicalY + window.y)
   - mouseClickAsync 转换后：(?)
4. 实际点击位置
5. 对比期望位置 vs 实际位置
```

## 当前代码的问题

### 问题 1：双重 DPR 转换

```typescript
// windowsDevice.ts - transformCoordinates
logicalX = x / windowDpr;  // 转换为窗口逻辑坐标
screenX = logicalX + window.x;  // 转换为屏幕逻辑坐标 ✓

// windowsNativeImpl.ts - mouseClickAsync
const logical = this.convertToLogicalCoordinates(screenX, screenY);  // ❌ 再次除以全屏 DPR
```

**如果窗口 DPR = 全屏 DPR**：

- 第一次转换：x / windowDpr ✓
- 第二次转换：(x / windowDpr) / screenDpr = x / (windowDpr * screenDpr) ✗
- **结果**：坐标被缩小了 DPR^2 倍

**如果窗口 DPR ≠ 全屏 DPR**：

- 转换使用错误的 DPR
- **结果**：坐标错误

### 问题 2：标题栏偏移未处理

如果截图包含标题栏，且 `window.y` 是客户区位置，需要减去标题栏高度。

## 推荐的修复方案

### 修复 1：避免双重 DPR 转换

**选项 A**：`transformCoordinates` 输出屏幕逻辑坐标，`mouseClickAsync` 不再转换

```typescript
// windowsDevice.ts
private transformCoordinates(x: number, y: number): { x: number; y: number } {
  // ... 当前逻辑，输出屏幕逻辑坐标
  return { x: screenX, y: screenY };  // 逻辑坐标
}

// windowsNativeImpl.ts - 新增方法
async mouseClickAsyncLogical(x: number, y: number): Promise<void> {
  // 直接使用，不再转换
  await mouse.move([new Point(x, y)]);
  await mouse.click(Button.LEFT);
}

// windowsDevice.ts - 修改调用
await windowsNative.mouseClickAsyncLogical(transformed.x, transformed.y);
```

**选项 B**：`transformCoordinates` 输出屏幕物理坐标，保持 `mouseClickAsync` 转换

```typescript
// windowsDevice.ts
// 需要将 window.x, y 转换为物理坐标
const screenPhysicalX = (logicalX + window.x) * screenDpr;
const screenPhysicalY = (logicalY + window.y) * screenDpr;
return { x: screenPhysicalX, y: screenPhysicalY };
```

**推荐选项 A**，因为：

- `window.x, y` 通常是逻辑坐标
- 鼠标操作最终需要逻辑坐标
- 避免双重转换

### 修复 2：处理标题栏偏移（如果确认需要）

```typescript
private transformCoordinates(x: number, y: number): { x: number; y: number } {
  // ... DPR 转换后
  
  // 如果截图包含标题栏，且 window.y 是客户区位置
  const TITLE_BAR_HEIGHT = 35;  // 或动态获取
  if (截图包含标题栏) {
    y = y - TITLE_BAR_HEIGHT;
  }
  
  // ... 后续转换
}
```

## 下一步行动

1. **验证**：实际测试截图是否包含标题栏，`window.y` 的含义
2. **修复双重 DPR 转换**：实现推荐方案 A
3. **测试**：验证修复效果
4. **优化**：如果需要，添加标题栏偏移处理
