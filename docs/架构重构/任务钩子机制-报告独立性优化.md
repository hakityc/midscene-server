# 任务钩子机制与报告独立性优化

## 问题背景

在原有架构中，`WebOperateService` 和 `WindowsOperateService` 使用单例模式，Agent 实例在服务启动时创建，停止时销毁。这导致一个严重问题：

**多次任务执行时，报告内容会累积，无法独立生成**

### 问题表现

- ❌ **第一次任务**：报告包含步骤 1、2、3
- ❌ **第二次任务**：报告包含步骤 1、2、3 + 4、5、6（累积了第一次的内容）
- ❌ **第三次任务**：报告包含所有 1-9 个步骤

### 根本原因

Agent 的 `dump` 数据结构会持续累积所有执行记录，每次调用 `writeOutActionDumps()` 生成报告时，都会包含之前所有任务的步骤。

## 解决方案

### 设计思路

引入 **任务钩子机制**（Task Hook Pattern），在任务执行的关键节点注入标准化处理逻辑：

1. **`beforeOperate`** - 任务开始前钩子：重置 dump，确保报告独立
2. **`afterOperate`** - 任务完成后钩子：生成并上传报告

### 架构优势

✅ **解决核心问题**：每个任务的报告完全独立
✅ **统一管理**：集中处理任务前后的通用逻辑
✅ **易于扩展**：预留扩展点，方便后续添加新功能
✅ **代码复用**：基类实现，所有子类自动继承
✅ **职责清晰**：钩子负责通用逻辑，业务方法专注核心任务

## 技术实现

### 1. 基类钩子定义

在 `BaseOperateService` 中添加两个核心钩子方法：

```typescript
// BaseOperateService.ts

/**
 * 任务执行前的钩子
 * 用于在每次任务开始前进行必要的初始化操作
 */
protected async beforeOperate(taskType: string): Promise<void> {
  if (!this.agent) {
    serviceLogger.warn('Agent 未初始化，跳过 beforeOperate 钩子');
    return;
  }

  try {
    // 1. 重置 dump，确保每个任务的报告独立
    if ('resetDump' in this.agent && typeof this.agent.resetDump === 'function') {
      (this.agent as any).resetDump();
      serviceLogger.info(
        { taskType },
        '✨ 已重置 Agent dump，开始新任务（报告将独立生成）',
      );
    }

    // 2. 预留扩展点：后续可以在这里添加其他前置逻辑
    // - 设置任务开始时间
    // - 记录任务上下文信息
    // - 清理临时资源
    // - 更新任务状态
  } catch (error) {
    // beforeOperate 失败不应该阻塞任务执行
    serviceLogger.warn(
      { error, taskType },
      '⚠️ beforeOperate 钩子执行失败，但不影响任务继续',
    );
  }
}

/**
 * 任务执行后的钩子
 * 用于在每次任务完成后进行清理和上报操作
 */
protected async afterOperate(
  taskType: string,
  success: boolean = true,
  error?: Error,
): Promise<void> {
  try {
    // 1. 生成并上传报告
    await this.generateAndUploadReport();

    // 2. 预留扩展点：后续可以在这里添加其他后置逻辑
    // - 记录任务执行时长
    // - 上报任务执行状态统计
    // - 发送任务完成通知
    // - 清理临时文件
    // - 更新任务历史记录

    if (!success && error) {
      serviceLogger.warn(
        { taskType, error: error.message },
        '⚠️ 任务执行失败，但 afterOperate 钩子正常完成',
      );
    }
  } catch (hookError: any) {
    // afterOperate 失败不应该抛出异常，避免覆盖原始错误
    serviceLogger.error(
      { hookError, taskType, success },
      '❌ afterOperate 钩子执行失败',
    );
  }
}
```

### 2. WebOperateServiceRefactored 集成

在所有任务方法中调用钩子：

#### execute 方法

```typescript
async execute(prompt: string, maxRetries: number = 3): Promise<void> {
  // ... 前置检查 ...

  // ✅ 任务开始前钩子
  await this.beforeOperate('execute');

  let lastError: any = null;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await this.agent.ai(prompt);

      // ✅ 任务成功，上传报告
      await this.afterOperate('execute', true);
      return;
    } catch (error: any) {
      lastError = error;

      if (this.isConnectionError(error) && attempt < maxRetries) {
        // 重连逻辑...
        continue;
      }

      // ✅ 任务失败，也上传报告
      await this.afterOperate('execute', false, error);
      throw error;
    }
  }

  // ✅ 所有重试都失败
  await this.afterOperate('execute', false, lastError);
  throw lastError;
}
```

#### expect 方法

```typescript
async expect(prompt: string, maxRetries: number = 3): Promise<void> {
  // ... 前置检查 ...

  // ✅ 任务开始前钩子
  await this.beforeOperate('expect');

  try {
    await this.agent.aiAssert(prompt);

    // ✅ 断言成功，上传报告
    await this.afterOperate('expect', true);
  } catch (error: any) {
    // ✅ 断言失败，也上传报告
    await this.afterOperate('expect', false, error);
    throw error;
  }
}
```

#### executeScript 方法

```typescript
async executeScript(prompt: string, maxRetries: number = 3): Promise<any> {
  // ... 前置检查 ...

  // ✅ 任务开始前钩子
  await this.beforeOperate('executeScript');

  try {
    const yamlResult = await this.agent.runYaml(prompt);

    // ✅ 脚本执行成功，上传报告
    await this.afterOperate('executeScript', true);
    return yamlResult;
  } catch (error: any) {
    // ✅ 脚本执行失败，上传报告
    await this.afterOperate('executeScript', false, error);
    throw error;
  }
}
```

### 3. WindowsOperateServiceRefactored 集成

同样在所有任务方法中调用钩子：

```typescript
async execute(prompt: string): Promise<void> {
  // ✅ 任务开始前钩子
  await this.beforeOperate('execute');

  try {
    await this.agent.aiAction(prompt);
    // ✅ 任务成功
    await this.afterOperate('execute', true);
  } catch (error: any) {
    // ✅ 任务失败
    await this.afterOperate('execute', false, error);
    throw error;
  }
}
```

## 实现效果

### 报告独立性保证

现在每次任务执行都会：

1. **开始前**：调用 `agent.resetDump()` 清空历史记录
2. **执行中**：只记录当前任务的操作步骤
3. **完成后**：生成仅包含当前任务的独立报告

### 执行流程示例

```typescript
// 第一次任务
await service.execute('登录系统');
// ✅ 报告文件：web-2025-01-27_10-00-00-abc123.html
// ✅ 内容：仅包含"登录系统"的步骤

// 第二次任务
await service.execute('搜索商品');
// ✅ 报告文件：web-2025-01-27_10-05-00-def456.html
// ✅ 内容：仅包含"搜索商品"的步骤（不包含登录）

// 第三次任务
await service.execute('添加购物车');
// ✅ 报告文件：web-2025-01-27_10-10-00-ghi789.html
// ✅ 内容：仅包含"添加购物车"的步骤（不包含之前任何操作）
```

## 扩展能力

钩子机制预留了灵活的扩展点，后续可以轻松添加新功能：

### beforeOperate 扩展示例

```typescript
protected async beforeOperate(taskType: string): Promise<void> {
  // 原有功能：重置 dump
  if ('resetDump' in this.agent) {
    (this.agent as any).resetDump();
  }

  // 扩展 1：记录任务开始时间
  this.taskStartTime = Date.now();

  // 扩展 2：设置任务上下文
  this.currentTaskContext = {
    type: taskType,
    startTime: this.taskStartTime,
    sessionId: generateSessionId(),
  };

  // 扩展 3：清理临时资源
  await this.cleanupTempFiles();

  // 扩展 4：发送任务开始通知
  await this.notifyTaskStart(taskType);
}
```

### afterOperate 扩展示例

```typescript
protected async afterOperate(
  taskType: string,
  success: boolean = true,
  error?: Error,
): Promise<void> {
  // 原有功能：生成并上传报告
  await this.generateAndUploadReport();

  // 扩展 1：记录任务执行时长
  const duration = Date.now() - this.taskStartTime;
  await this.recordTaskMetrics({
    type: taskType,
    duration,
    success,
  });

  // 扩展 2：上报任务统计
  await this.reportTaskAnalytics({
    taskType,
    success,
    errorMessage: error?.message,
    duration,
  });

  // 扩展 3：发送任务完成通知
  await this.notifyTaskComplete({
    taskType,
    success,
    duration,
  });

  // 扩展 4：清理任务上下文
  this.currentTaskContext = null;
}
```

## 技术要点

### 1. 错误处理策略

**beforeOperate**：

- 失败不阻塞任务执行
- 记录警告日志，但继续执行任务

**afterOperate**：

- 失败不抛出异常，避免覆盖原始业务错误
- 记录错误日志，确保问题可追踪

### 2. 报告上传时机

无论任务成功还是失败，都会上传报告：

- **成功**：上传完整的执行报告
- **失败**：上传包含错误信息的报告，便于调试

### 3. 类型安全

使用 TypeScript 类型检查确保钩子参数正确：

```typescript
protected async beforeOperate(taskType: string): Promise<void>

protected async afterOperate(
  taskType: string,
  success: boolean = true,
  error?: Error,
): Promise<void>
```

## 相关文件

### 修改的文件

1. **`apps/server/src/services/base/BaseOperateService.ts`**
   - 新增 `beforeOperate()` 钩子方法
   - 新增 `afterOperate()` 钩子方法

2. **`apps/server/src/services/base/WebOperateServiceRefactored.ts`**
   - `execute()` 方法集成钩子
   - `expect()` 方法集成钩子
   - `executeScript()` 方法集成钩子

3. **`apps/server/src/services/base/WindowsOperateServiceRefactored.ts`**
   - `execute()` 方法集成钩子
   - `expect()` 方法集成钩子
   - `executeScript()` 方法集成钩子

### 未修改的文件

- `webOperateService.ts` - 保留旧版实现，待后续迁移
- `windowsOperateService.ts` - 保留旧版实现，待后续迁移

## 后续优化建议

1. **任务统计**：在钩子中添加任务执行时间、成功率等统计
2. **性能监控**：记录每个任务的性能指标
3. **通知机制**：任务完成后发送通知（邮件、webhook 等）
4. **资源清理**：自动清理旧的报告文件和临时文件
5. **任务链追踪**：支持多任务关联追踪

## 总结

通过引入任务钩子机制，我们成功解决了报告累积问题，同时为系统提供了强大的扩展能力。这是一个典型的**面向切面编程（AOP）**实践，将横切关注点（报告管理、资源清理等）从业务逻辑中分离出来，提升了代码的可维护性和可扩展性。
